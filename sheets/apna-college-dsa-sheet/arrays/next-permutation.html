<h1 id="next-permutation">Next Permutation</h1>

<h2 id="brute">Brute</h2>

<p>Time Complexity: O(n! * n)</p>

<ol>
  <li>Find all permutations in sorted manner</li>
  <li>Locate current permutation among all permutations</li>
  <li>Modify current permutation to match the next permutation if it exists otherwise
sort it</li>
</ol>

<h2 id="optimal">Optimal</h2>

<p>Time Complexity: O(n)</p>

<ol>
  <li>
    <p>Write all permutations of <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, 5]</code>, and u will notice that,
we try to keep the starting array common among permutation to get next permutation
so <code class="language-plaintext highlighter-rouge">[1, 2, 3, 5, 4]</code>, <code class="language-plaintext highlighter-rouge">123</code> stays same.</p>
  </li>
  <li>
    <p>Find the Pivot point:</p>

    <ul>
      <li>Pivot pt is where <code class="language-plaintext highlighter-rouge">arr[i] &lt; arr[i+1]</code>. We have to find the last pivot pt
because we want to keep the prefix array as long as possible</li>
      <li>Start from the end, and break at first sight of pivt pt</li>
      <li><strong>Edge Case:</strong> no pivot pt. In final permutation (ie descending arr) there
wonâ€™t be any pivot, pt so return the reversed array as ans</li>
    </ul>
  </li>
  <li>Find least maximum of pivot number in <code class="language-plaintext highlighter-rouge">arr[pivot_idx + 1:]</code> and swap it
with pivot</li>
  <li>Sort the array after <code class="language-plaintext highlighter-rouge">pivot_idx</code>. U can just reverse the array as it already
is in descending order</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">nextPermutation</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Do not return anything, modify arr in-place instead.
        </span><span class="sh">"""</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="c1"># find the pivot index, starting from end
</span>        <span class="n">pvt_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">pvt_idx</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>

        <span class="c1"># if no pvt idx is found, then no further permutation exists
</span>        <span class="c1"># so just return sorted array which will be reverse of curr arr
</span>        <span class="k">if</span> <span class="n">pvt_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_reverse_arr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># if found, swap it with least maximum towards right side of it
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pvt_idx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">pvt_idx</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">pvt_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">pvt_idx</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">break</span>

        <span class="c1"># sort the sub-array towards right of pvt idx, which is in descending
</span>        <span class="c1"># order, so reverse it
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">_reverse_arr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pvt_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reverse_arr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Reverses the subarray from index `start` to `end` (inclusive) in place
        </span><span class="sh">"""</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">end</span> <span class="o">-=</span> <span class="mi">1</span>
</code></pre></div></div>
